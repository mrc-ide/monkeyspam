// Generated by odin.dust (version 0.2.26) - do not edit
template <typename real_type, typename T, typename U>
__host__ __device__ real_type fmodr(T x, U y) {
  real_type tmp = std::fmod(static_cast<real_type>(x),
                            static_cast<real_type>(y));
  if (tmp * y < 0) {
    tmp += y;
  }
  return tmp;
}

// These exist to support the model on the gpu, as in C++14 std::min
// and std::max are constexpr and error without --expt-relaxed-constexpr
template <typename T>
__host__ __device__ T odin_min(T x, T y) {
  return x < y ? x : y;
}

template <typename T>
__host__ __device__ T odin_max(T x, T y) {
  return x > y ? x : y;
}
// [[dust::class(m4)]]
// [[dust::param(N, has_default = TRUE, default_value = 419322.4, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta, has_default = TRUE, default_value = 2.25, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta, has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(etaf, has_default = TRUE, default_value = 0.005, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(etag, has_default = TRUE, default_value = 0.01, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(gamma0, has_default = TRUE, default_value = 0.125, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(gamma1, has_default = TRUE, default_value = 0.25, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(i0, has_default = TRUE, default_value = 0L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(seedrate0, has_default = TRUE, default_value = 0.75, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(seedrate_sd, has_default = TRUE, default_value = 0.05, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_amt, has_default = TRUE, default_value = 0.04, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_fin_day, has_default = TRUE, default_value = 126L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_freq, has_default = TRUE, default_value = 7L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_start_day, has_default = TRUE, default_value = 91L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
class m4 {
public:
  using real_type = double;
  using rng_state_type = dust::random::generator<real_type>;
  using data_type = dust::no_data;
  struct shared_type {
    real_type N;
    real_type beta;
    real_type delta;
    real_type etaf;
    real_type etag;
    real_type fp1;
    real_type gamma0;
    real_type gamma1;
    real_type gp1;
    real_type hp1;
    real_type hrate;
    real_type hshape;
    real_type i0;
    real_type initial_E;
    real_type initial_I;
    real_type initial_MEf;
    real_type initial_MEg;
    real_type initial_MEh;
    real_type initial_MIf;
    real_type initial_MIg;
    real_type initial_MIh;
    real_type initial_MSEf;
    real_type initial_MSEg;
    real_type initial_MSIf;
    real_type initial_MSIg;
    real_type initial_MSSf;
    real_type initial_MSSg;
    real_type initial_cutf;
    real_type initial_cutg;
    real_type initial_cuth;
    real_type initial_cuts;
    real_type initial_newI;
    real_type initial_seedrate;
    real_type initial_theta_vacc;
    real_type initial_thetaf;
    real_type initial_thetag;
    real_type initial_thetah;
    real_type pgf_f2;
    real_type pgf_f3;
    real_type pgf_g3;
    real_type rf;
    real_type rg;
    real_type seedrate0;
    real_type seedrate_sd;
    real_type vacc_amt;
    real_type vacc_fin_day;
    real_type vacc_freq;
    real_type vacc_start_day;
    real_type xinit;
  };
  struct internal_type {
  };
  m4(const dust::pars_type<m4>& pars) :
    shared(pars.shared), internal(pars.internal) {
  }
  size_t size() {
    return 24;
  }
  std::vector<real_type> initial(size_t step) {
    std::vector<real_type> state(24);
    state[0] = shared->initial_thetaf;
    state[1] = shared->initial_MSEf;
    state[2] = shared->initial_MEf;
    state[3] = shared->initial_MSSf;
    state[4] = shared->initial_MSIf;
    state[5] = shared->initial_MIf;
    state[6] = shared->initial_thetag;
    state[7] = shared->initial_MSEg;
    state[8] = shared->initial_MEg;
    state[9] = shared->initial_MSSg;
    state[10] = shared->initial_MSIg;
    state[11] = shared->initial_MIg;
    state[12] = shared->initial_thetah;
    state[13] = shared->initial_MEh;
    state[14] = shared->initial_MIh;
    state[15] = shared->initial_E;
    state[16] = shared->initial_I;
    state[17] = shared->initial_newI;
    state[18] = shared->initial_cutf;
    state[19] = shared->initial_cutg;
    state[20] = shared->initial_cuth;
    state[21] = shared->initial_cuts;
    state[22] = shared->initial_seedrate;
    state[23] = shared->initial_theta_vacc;
    return state;
  }
  void update(size_t step, const real_type * state, rng_state_type& rng_state, real_type * state_next) {
    const real_type thetaf = state[0];
    const real_type MSEf = state[1];
    const real_type MEf = state[2];
    const real_type MSSf = state[3];
    const real_type MSIf = state[4];
    const real_type MIf = state[5];
    const real_type thetag = state[6];
    const real_type MSEg = state[7];
    const real_type MEg = state[8];
    const real_type MSSg = state[9];
    const real_type MSIg = state[10];
    const real_type MIg = state[11];
    const real_type thetah = state[12];
    const real_type MEh = state[13];
    const real_type MIh = state[14];
    const real_type E = state[15];
    const real_type I = state[16];
    const real_type newI = state[17];
    const real_type cutf = state[18];
    const real_type cutg = state[19];
    const real_type cuth = state[20];
    const real_type cuts = state[21];
    const real_type seedrate = state[22];
    const real_type theta_vacc = state[23];
    real_type I_next = std::max(static_cast<real_type>(0), I + shared->gamma0 * E - shared->gamma1 * I);
    real_type dMIf = - shared->gamma1 * MIf + shared->gamma0 * MEf;
    real_type dMIg = - shared->gamma1 * MIg + shared->gamma0 * MEg;
    real_type dMIh = - shared->gamma1 * MIh + shared->gamma0 * MEh;
    real_type p0 = std::pow((1 - std::log(theta_vacc) / (real_type) shared->hrate), (- shared->hshape));
    real_type pgf_f0 = (2809 + 2000 * thetaf + 95 * std::pow(thetaf, 2)) / (real_type) 4904;
    real_type pgf_f1 = (2000 + 2 * 95 * thetaf) / (real_type) 4904;
    real_type pgf_g0 = (2943 + 1009 * thetag + 477 * std::pow(thetag, 2) + 475 * std::pow(thetag, 3)) / (real_type) 4904;
    real_type pgf_g1 = (1009 + 2 * 477 * thetag + 3 * 475 * std::pow(thetag, 2)) / (real_type) 4904;
    real_type pgf_g2 = (2 * 477 + 2 * 3 * 475 * thetag) / (real_type) 4904;
    real_type seedrate_next = std::max(static_cast<real_type>(0), seedrate + dust::random::normal<real_type>(rng_state, 0, shared->seedrate_sd));
    real_type time = step;
    state_next[23] = theta_vacc;
    real_type MSf = thetaf * pgf_f1 / (real_type) shared->fp1;
    real_type MSg = thetag * pgf_g1 / (real_type) shared->gp1;
    real_type add_vaccine = (time >= shared->vacc_start_day) && (time <= shared->vacc_fin_day) && ((fmodr<real_type>((time - shared->vacc_start_day), shared->vacc_freq)) == 0);
    real_type meanfield_delta_si_f = (thetaf * shared->pgf_f2 / (real_type) pgf_f1);
    real_type meanfield_delta_si_g = (thetag * pgf_g2 / (real_type) pgf_g1);
    real_type p1 = std::max(0.01, p0 - shared->vacc_amt);
    real_type transmh = dust::random::poisson<real_type>(rng_state, shared->beta * MIh * shared->N * shared->hp1);
    real_type transmseed = dust::random::poisson<real_type>(rng_state, seedrate_next);
    real_type u2f = (thetaf * shared->pgf_f2 + std::pow(thetaf, 2) * shared->pgf_f3) / (real_type) pgf_f1;
    real_type u2g = (thetag * pgf_g2 + std::pow(thetag, 2) * shared->pgf_g3) / (real_type) pgf_g1;
    state_next[16] = I_next;
    state_next[5] = std::max(static_cast<real_type>(0), MIf + dMIf);
    state_next[11] = std::max(static_cast<real_type>(0), MIg + dMIg);
    state_next[14] = std::max(static_cast<real_type>(0), MIh + dMIh);
    state_next[22] = seedrate_next;
    real_type theta_vacc_use = (add_vaccine ? std::exp((1 - std::pow(p1, (- 1 / (real_type) shared->hshape))) * shared->hrate) : theta_vacc);
    real_type u1f = meanfield_delta_si_f;
    real_type u1g = meanfield_delta_si_g;
    state_next[20] = cuth + transmh;
    state_next[21] = cuts + transmseed;
    real_type vaccine_scale = (add_vaccine ? 1 - shared->vacc_amt : 1);
    real_type MSEf_vacc = MSEf * vaccine_scale;
    real_type MSEg_vacc = MSEg * vaccine_scale;
    real_type MSIf_vacc = MSIf * vaccine_scale;
    real_type MSIg_vacc = MSIg * vaccine_scale;
    real_type MSSf_vacc = MSSf * std::pow(vaccine_scale, 2);
    real_type MSSg_vacc = MSSg * std::pow(vaccine_scale, 2);
    real_type dot_thetah = thetah * theta_vacc_use;
    real_type vf = u2f - std::pow(u1f, 2);
    real_type vg = u2g - std::pow(u1g, 2);
    real_type dthetah = - dot_thetah * (transmh + transmseed) / (real_type) (shared->N * shared->hp1);
    real_type pgf_h0 = std::pow((1 - std::log(dot_thetah) / (real_type) shared->hrate), (- shared->hshape));
    real_type pgf_h1 = shared->hshape * std::pow((1 - std::log(dot_thetah) / (real_type) shared->hrate), (- shared->hshape - 1)) / (real_type) ((shared->hrate * dot_thetah));
    real_type pgf_h2 = shared->hshape * std::pow(((shared->hrate - std::log(dot_thetah)) / (real_type) shared->hrate), (- shared->hshape)) * (- shared->hrate + shared->hshape + std::log(dot_thetah) + 1) / (real_type) (std::pow(dot_thetah, 2) * std::pow((shared->hrate - std::log(dot_thetah)), 2));
    real_type pgf_h3 = shared->hshape * std::pow(((shared->hrate - std::log(dot_thetah)) / (real_type) shared->hrate), (- shared->hshape)) * (std::pow(shared->hshape, 2) + 3 * shared->hshape + 2 * std::pow((shared->hrate - std::log(dot_thetah)), 2) - 3 * (shared->hrate - std::log(dot_thetah)) * (shared->hshape + 1) + 2) / (real_type) (std::pow(dot_thetah, 3) * std::pow((shared->hrate - std::log(dot_thetah)), 3));
    real_type transmf = dust::random::poisson<real_type>(rng_state, MSIf_vacc * shared->N * shared->fp1 * shared->rf);
    real_type transmg = dust::random::poisson<real_type>(rng_state, MSIg_vacc * shared->N * shared->gp1 * shared->rg);
    real_type dSh = pgf_h1 * dthetah;
    real_type delta_si_f = ((transmf == 0 ? 0 : dust::random::normal<real_type>(rng_state, meanfield_delta_si_f, std::sqrt(vf / (real_type) transmf))));
    real_type delta_si_g = ((transmg == 0 ? 0 : dust::random::normal<real_type>(rng_state, meanfield_delta_si_g, std::sqrt(vg / (real_type) transmg))));
    real_type dthetaf = - thetaf * transmf / (real_type) (MSf * shared->N * shared->fp1);
    real_type dthetag = - thetag * transmg / (real_type) (MSg * shared->N * shared->gp1);
    real_type meanfield_delta_si_h = (1 + dot_thetah * pgf_h2 / (real_type) pgf_h1);
    real_type newE = transmf + transmg + transmh + transmseed;
    state_next[18] = cutf + transmf;
    state_next[19] = cutg + transmg;
    state_next[12] = std::max(1.0000000000000001e-09, std::min(static_cast<real_type>(1), thetah + dthetah));
    real_type E_next = std::max(static_cast<real_type>(0), E + newE - shared->gamma0 * E);
    real_type dSf = pgf_f1 * dthetaf;
    real_type dSg = pgf_g1 * dthetag;
    real_type u1h = meanfield_delta_si_h;
    state_next[0] = std::max(1.0000000000000001e-09, std::min(static_cast<real_type>(1), thetaf + dthetaf));
    state_next[6] = std::max(1.0000000000000001e-09, std::min(static_cast<real_type>(1), thetag + dthetag));
    real_type dMEf = - shared->gamma0 * MEf + (- dSf) * (delta_si_f / (real_type) shared->fp1) + ((- dSg) + (- dSh)) * (thetaf * pgf_f1 / (real_type) pgf_f0 / (real_type) shared->fp1);
    real_type dMEg = - shared->gamma0 * MEg + (- dSg) * (delta_si_g / (real_type) shared->gp1) + ((- dSf) + (- dSh)) * (thetag * pgf_g1 / (real_type) pgf_g0 / (real_type) shared->gp1);
    real_type dMSEf = - shared->gamma1 * MSEf_vacc + 2 * shared->etaf * MSf * MEf - shared->etaf * MSEf_vacc + (- dSf) * (delta_si_f / (real_type) shared->fp1) * (MSSf_vacc / (real_type) MSf) + (- dSg) * (thetaf * pgf_f1 / (real_type) pgf_f0 / (real_type) shared->fp1) * (MSSf_vacc / (real_type) MSf) + (- dSh) * (thetaf * pgf_f1 / (real_type) pgf_f0 / (real_type) shared->fp1) * (MSSf_vacc / (real_type) MSf);
    real_type dMSEg = - shared->gamma0 * MSEg_vacc + 2 * shared->etag * MSg * MEg - shared->etag * MSEg_vacc + (- dSg) * (delta_si_g / (real_type) shared->gp1) * (MSSg_vacc / (real_type) MSg) + (- dSf) * (thetag * pgf_g1 / (real_type) pgf_g0 / (real_type) shared->gp1) * (MSSg_vacc / (real_type) MSg) + (- dSh) * (thetag * pgf_g1 / (real_type) pgf_g0 / (real_type) shared->gp1) * (MSSg_vacc / (real_type) MSg);
    real_type dMSIf = - shared->rf * MSIf_vacc - shared->gamma1 * MSIf_vacc + shared->gamma0 * MSEf_vacc + 2 * shared->etaf * MSf * MIf - shared->etaf * MSIf_vacc + (- dSf) * (delta_si_f / (real_type) shared->fp1) * (- MSIf_vacc / (real_type) MSf) + (- dSg) * (thetaf * pgf_f1 / (real_type) pgf_f0 / (real_type) shared->fp1) * (- MSIf_vacc / (real_type) MSf) + (- dSh) * (thetaf * pgf_f1 / (real_type) pgf_f0 / (real_type) shared->fp1) * (- MSIf_vacc / (real_type) MSf);
    real_type dMSIg = - shared->rg * MSIg_vacc - shared->gamma1 * MSIg_vacc + shared->gamma0 * MSEg_vacc + 2 * shared->etag * MSg * MIg - shared->etag * MSIg_vacc + (- dSg) * (delta_si_g / (real_type) shared->gp1) * (- MSIg_vacc / (real_type) MSg) + (- dSf) * (thetag * pgf_g1 / (real_type) pgf_g0 / (real_type) shared->gp1) * (- MSIg_vacc / (real_type) MSg) + (- dSh) * (thetag * pgf_g1 / (real_type) pgf_g0 / (real_type) shared->gp1) * (- MSIg_vacc / (real_type) MSg);
    real_type dMSSf = 1 * shared->etaf * std::pow(MSf, 2) - shared->etaf * MSSf_vacc - (- dSf) * (delta_si_f / (real_type) shared->fp1) * MSSf_vacc / (real_type) MSf - ((- dSg) + (- dSh)) * (thetaf * pgf_f1 / (real_type) pgf_f0 / (real_type) shared->fp1) * MSSf_vacc / (real_type) MSf;
    real_type dMSSg = 1 * shared->etag * std::pow(MSg, 2) - shared->etag * MSSg_vacc - (- dSg) * (delta_si_g / (real_type) shared->gp1) * MSSg_vacc / (real_type) MSg - ((- dSf) + (- dSh)) * (thetag * pgf_g1 / (real_type) pgf_g0 / (real_type) shared->gp1) * MSSg_vacc / (real_type) MSg;
    real_type u2h = pgf_h3 * std::pow(dot_thetah, 2) / (real_type) pgf_h1 + 2 * dot_thetah * pgf_h2 / (real_type) pgf_h1 + u1h;
    state_next[15] = E_next;
    state_next[17] = newI + shared->gamma0 * E_next;
    state_next[2] = std::max(static_cast<real_type>(0), MEf + dMEf);
    state_next[8] = std::max(static_cast<real_type>(0), MEg + dMEg);
    state_next[1] = std::max(static_cast<real_type>(0), MSEf_vacc + dMSEf);
    state_next[7] = std::max(static_cast<real_type>(0), MSEg_vacc + dMSEg);
    state_next[4] = std::max(static_cast<real_type>(0), MSIf_vacc + dMSIf);
    state_next[10] = std::max(static_cast<real_type>(0), MSIg_vacc + dMSIg);
    state_next[3] = std::max(static_cast<real_type>(0), MSSf_vacc + dMSSf);
    state_next[9] = std::max(static_cast<real_type>(0), MSSg_vacc + dMSSg);
    real_type vh = u2h - std::pow(u1h, 2);
    real_type delta_si_h = ((transmh == 0 ? 0 : dust::random::normal<real_type>(rng_state, meanfield_delta_si_h, std::sqrt(vh / (real_type) transmh))));
    real_type dMEh = - shared->gamma0 * MEh + (- dSh) * (delta_si_h / (real_type) shared->hp1) + ((- dSf) + (- dSg)) * (dot_thetah * pgf_h1 / (real_type) pgf_h0 / (real_type) shared->hp1);
    state_next[13] = std::max(static_cast<real_type>(0), MEh + dMEh);
  }
private:
  std::shared_ptr<const shared_type> shared;
  internal_type internal;
};
#include <array>
#include <cpp11/R.hpp>
#include <cpp11/sexp.hpp>
#include <cpp11/doubles.hpp>
#include <cpp11/integers.hpp>
#include <cpp11/list.hpp>
#include <cpp11/strings.hpp>
#include <memory>
#include <vector>

template <typename T>
inline bool is_na(T x);

template <>
inline bool is_na(int x) {
  return x == NA_INTEGER;
}

template <>
inline bool is_na(double x) {
  return ISNA(x);
}

inline size_t object_length(cpp11::sexp x) {
  return ::Rf_xlength(x);
}

template <typename T>
void user_check_value(T value, const char *name, T min, T max) {
  if (is_na(value)) {
    cpp11::stop("'%s' must not be NA", name);
  }
  if (!is_na(min) && value < min) {
    cpp11::stop("Expected '%s' to be at least %g", name, (double) min);
  }
  if (!is_na(max) && value > max) {
    cpp11::stop("Expected '%s' to be at most %g", name, (double) max);
  }
}

template <typename T>
void user_check_array_value(const std::vector<T>& value, const char *name,
                            T min, T max) {
  for (auto& x : value) {
    user_check_value(x, name, min, max);
  }
}

inline size_t user_get_array_rank(cpp11::sexp x) {
  if (!::Rf_isArray(x)) {
    return 1;
  } else {
    cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
    return dim.size();
  }
}

template <size_t N>
void user_check_array_rank(cpp11::sexp x, const char *name) {
  size_t rank = user_get_array_rank(x);
  if (rank != N) {
    if (N == 1) {
      cpp11::stop("Expected a vector for '%s'", name);
    } else if (N == 2) {
      cpp11::stop("Expected a matrix for '%s'", name);
    } else {
      cpp11::stop("Expected an array of rank %d for '%s'", N, name);
    }
  }
}

template <size_t N>
void user_check_array_dim(cpp11::sexp x, const char *name,
                          const std::array<int, N>& dim_expected) {
  cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  for (size_t i = 0; i < N; ++i) {
    if (dim[(int)i] != dim_expected[i]) {
      Rf_error("Incorrect size of dimension %d of '%s' (expected %d)",
               i + 1, name, dim_expected[i]);
    }
  }
}

template <>
inline void user_check_array_dim<1>(cpp11::sexp x, const char *name,
                                    const std::array<int, 1>& dim_expected) {
  if ((int)object_length(x) != dim_expected[0]) {
    cpp11::stop("Expected length %d value for '%s'", dim_expected[0], name);
  }
}

template <size_t N>
void user_set_array_dim(cpp11::sexp x, const char *name,
                        std::array<int, N>& dim) {
  cpp11::integers dim_given = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  std::copy(dim_given.begin(), dim_given.end(), dim.begin());
}

template <>
inline void user_set_array_dim<1>(cpp11::sexp x, const char *name,
                                  std::array<int, 1>& dim) {
  dim[0] = object_length(x);
}

template <typename T>
T user_get_scalar(cpp11::list user, const char *name,
                  const T previous, T min, T max) {
  T ret = previous;
  cpp11::sexp x = user[name];
  if (x != R_NilValue) {
    if (object_length(x) != 1) {
      cpp11::stop("Expected a scalar numeric for '%s'", name);
    }
    // TODO: when we're getting out an integer this is a bit too relaxed
    if (TYPEOF(x) == REALSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else if (TYPEOF(x) == INTSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else {
      cpp11::stop("Expected a numeric value for %s", name);
    }
  }

  if (is_na(ret)) {
    cpp11::stop("Expected a value for '%s'", name);
  }
  user_check_value<T>(ret, name, min, max);
  return ret;
}

template <>
inline float user_get_scalar<float>(cpp11::list user, const char *name,
                                    const float previous, float min, float max) {
  double value = user_get_scalar<double>(user, name, previous, min, max);
  return static_cast<float>(value);
}

template <typename T>
std::vector<T> user_get_array_value(cpp11::sexp x, const char * name,
                                    T min, T max) {
  std::vector<T> ret = cpp11::as_cpp<std::vector<T>>(x);
  user_check_array_value<T>(ret, name, min, max);
  return ret;
}

template <typename T, size_t N>
std::vector<T> user_get_array_fixed(cpp11::list user, const char *name,
                                    const std::vector<T> previous,
                                    const std::array<int, N>& dim,
                                    T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_check_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <typename T, size_t N>
std::vector<T> user_get_array_variable(cpp11::list user, const char *name,
                                       std::vector<T> previous,
                                       std::array<int, N>& dim,
                                       T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_set_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <>
inline std::vector<float> user_get_array_value(cpp11::sexp x, const char * name,
                                               float min, float max) {
  // NOTE: possible under/overflow here for min/max because we've
  // downcast this.
  std::vector<double> value = user_get_array_value<double>(x, name, min, max);
  std::vector<float> ret(value.size());
  std::copy(value.begin(), value.end(), ret.begin());
  return ret;
}

// This is sum with inclusive "from", exclusive "to", following the
// same function in odin
template <typename real_type, typename container>
__host__ __device__
real_type odin_sum1(const container x, size_t from, size_t to) {
  real_type tot = 0.0;
  for (size_t i = from; i < to; ++i) {
    tot += x[i];
  }
  return tot;
}

inline cpp11::writable::integers integer_sequence(size_t from, size_t len) {
  cpp11::writable::integers ret(len);
  int* data = INTEGER(ret);
  for (size_t i = 0, j = from; i < len; ++i, ++j) {
    data[i] = j;
  }
  return ret;
}
namespace dust {
template<>
dust::pars_type<m4> dust_pars<m4>(cpp11::list user) {
  using real_type = typename m4::real_type;
  auto shared = std::make_shared<m4::shared_type>();
  m4::internal_type internal;
  shared->fp1 = (2000 + 2 * 95) / (real_type) 4904;
  shared->gp1 = (1009 + 2 * 477 + 3 * 475) / (real_type) 4904;
  shared->hrate = 1.8500000000000001 * 7;
  shared->hshape = 0.26000000000000001;
  shared->initial_MEf = 0;
  shared->initial_MEg = 0;
  shared->initial_MIf = 0;
  shared->initial_MIg = 0;
  shared->initial_MSEf = 0;
  shared->initial_MSEg = 0;
  shared->initial_MSIf = 0;
  shared->initial_MSIg = 0;
  shared->initial_MSSf = 1;
  shared->initial_MSSg = 1;
  shared->initial_cutf = 0;
  shared->initial_cutg = 0;
  shared->initial_cuth = 0;
  shared->initial_cuts = 0;
  shared->initial_newI = 0;
  shared->initial_theta_vacc = 1;
  shared->initial_thetaf = 1;
  shared->initial_thetag = 1;
  shared->pgf_f2 = (2 * 95) / (real_type) 4904;
  shared->pgf_f3 = 0;
  shared->pgf_g3 = (2 * 3 * 475) / (real_type) 4904;
  shared->hp1 = shared->hshape / (real_type) shared->hrate;
  shared->N = 419322.40000000002;
  shared->beta = 2.25;
  shared->delta = 0.40000000000000002;
  shared->etaf = 0.0050000000000000001;
  shared->etag = 0.01;
  shared->gamma0 = 0.125;
  shared->gamma1 = 0.25;
  shared->i0 = 0;
  shared->seedrate0 = 0.75;
  shared->seedrate_sd = 0.050000000000000003;
  shared->vacc_amt = 0.040000000000000001;
  shared->vacc_fin_day = 126;
  shared->vacc_freq = 7;
  shared->vacc_start_day = 91;
  shared->N = user_get_scalar<real_type>(user, "N", shared->N, NA_REAL, NA_REAL);
  shared->beta = user_get_scalar<real_type>(user, "beta", shared->beta, NA_REAL, NA_REAL);
  shared->delta = user_get_scalar<real_type>(user, "delta", shared->delta, NA_REAL, NA_REAL);
  shared->etaf = user_get_scalar<real_type>(user, "etaf", shared->etaf, NA_REAL, NA_REAL);
  shared->etag = user_get_scalar<real_type>(user, "etag", shared->etag, NA_REAL, NA_REAL);
  shared->gamma0 = user_get_scalar<real_type>(user, "gamma0", shared->gamma0, NA_REAL, NA_REAL);
  shared->gamma1 = user_get_scalar<real_type>(user, "gamma1", shared->gamma1, NA_REAL, NA_REAL);
  shared->i0 = user_get_scalar<real_type>(user, "i0", shared->i0, NA_REAL, NA_REAL);
  shared->seedrate0 = user_get_scalar<real_type>(user, "seedrate0", shared->seedrate0, NA_REAL, NA_REAL);
  shared->seedrate_sd = user_get_scalar<real_type>(user, "seedrate_sd", shared->seedrate_sd, NA_REAL, NA_REAL);
  shared->vacc_amt = user_get_scalar<real_type>(user, "vacc_amt", shared->vacc_amt, NA_REAL, NA_REAL);
  shared->vacc_fin_day = user_get_scalar<real_type>(user, "vacc_fin_day", shared->vacc_fin_day, NA_REAL, NA_REAL);
  shared->vacc_freq = user_get_scalar<real_type>(user, "vacc_freq", shared->vacc_freq, NA_REAL, NA_REAL);
  shared->vacc_start_day = user_get_scalar<real_type>(user, "vacc_start_day", shared->vacc_start_day, NA_REAL, NA_REAL);
  shared->initial_seedrate = shared->seedrate0;
  shared->rf = shared->beta * 1.5 / (real_type) 7;
  shared->rg = shared->beta * 1 / (real_type) 7;
  shared->xinit = shared->i0 / (real_type) shared->N;
  shared->initial_E = shared->xinit * shared->N / (real_type) 2;
  shared->initial_I = shared->xinit * shared->N / (real_type) 2;
  shared->initial_MEh = shared->xinit / (real_type) 2;
  shared->initial_MIh = shared->xinit / (real_type) 2;
  shared->initial_thetah = 1 - shared->xinit;
  return dust::pars_type<m4>(shared, internal);
}
template <>
cpp11::sexp dust_info<m4>(const dust::pars_type<m4>& pars) {
  const m4::internal_type internal = pars.internal;
  const std::shared_ptr<const m4::shared_type> shared = pars.shared;
  cpp11::writable::strings nms({"thetaf", "MSEf", "MEf", "MSSf", "MSIf", "MIf", "thetag", "MSEg", "MEg", "MSSg", "MSIg", "MIg", "thetah", "MEh", "MIh", "E", "I", "newI", "cutf", "cutg", "cuth", "cuts", "seedrate", "theta_vacc"});
  cpp11::writable::list dim(24);
  dim[0] = cpp11::writable::integers({1});
  dim[1] = cpp11::writable::integers({1});
  dim[2] = cpp11::writable::integers({1});
  dim[3] = cpp11::writable::integers({1});
  dim[4] = cpp11::writable::integers({1});
  dim[5] = cpp11::writable::integers({1});
  dim[6] = cpp11::writable::integers({1});
  dim[7] = cpp11::writable::integers({1});
  dim[8] = cpp11::writable::integers({1});
  dim[9] = cpp11::writable::integers({1});
  dim[10] = cpp11::writable::integers({1});
  dim[11] = cpp11::writable::integers({1});
  dim[12] = cpp11::writable::integers({1});
  dim[13] = cpp11::writable::integers({1});
  dim[14] = cpp11::writable::integers({1});
  dim[15] = cpp11::writable::integers({1});
  dim[16] = cpp11::writable::integers({1});
  dim[17] = cpp11::writable::integers({1});
  dim[18] = cpp11::writable::integers({1});
  dim[19] = cpp11::writable::integers({1});
  dim[20] = cpp11::writable::integers({1});
  dim[21] = cpp11::writable::integers({1});
  dim[22] = cpp11::writable::integers({1});
  dim[23] = cpp11::writable::integers({1});
  dim.names() = nms;
  cpp11::writable::list index(24);
  index[0] = cpp11::writable::integers({1});
  index[1] = cpp11::writable::integers({2});
  index[2] = cpp11::writable::integers({3});
  index[3] = cpp11::writable::integers({4});
  index[4] = cpp11::writable::integers({5});
  index[5] = cpp11::writable::integers({6});
  index[6] = cpp11::writable::integers({7});
  index[7] = cpp11::writable::integers({8});
  index[8] = cpp11::writable::integers({9});
  index[9] = cpp11::writable::integers({10});
  index[10] = cpp11::writable::integers({11});
  index[11] = cpp11::writable::integers({12});
  index[12] = cpp11::writable::integers({13});
  index[13] = cpp11::writable::integers({14});
  index[14] = cpp11::writable::integers({15});
  index[15] = cpp11::writable::integers({16});
  index[16] = cpp11::writable::integers({17});
  index[17] = cpp11::writable::integers({18});
  index[18] = cpp11::writable::integers({19});
  index[19] = cpp11::writable::integers({20});
  index[20] = cpp11::writable::integers({21});
  index[21] = cpp11::writable::integers({22});
  index[22] = cpp11::writable::integers({23});
  index[23] = cpp11::writable::integers({24});
  index.names() = nms;
  size_t len = 24;
  using namespace cpp11::literals;
  return cpp11::writable::list({
           "dim"_nm = dim,
           "len"_nm = len,
           "index"_nm = index});
}
}
