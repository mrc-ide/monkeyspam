// Generated by odin.dust (version 0.3.3) - do not edit
template <typename real_type, typename T, typename U>
__host__ __device__ real_type fmodr(T x, U y) {
  real_type tmp = std::fmod(static_cast<real_type>(x),
                            static_cast<real_type>(y));
  if (tmp * y < 0) {
    tmp += y;
  }
  return tmp;
}

// These exist to support the model on the gpu, as in C++14 std::min
// and std::max are constexpr and error without --expt-relaxed-constexpr
template <typename T>
__host__ __device__ T odin_min(T x, T y) {
  return x < y ? x : y;
}

template <typename T>
__host__ __device__ T odin_max(T x, T y) {
  return x > y ? x : y;
}

template <typename T>
__host__ __device__ T odin_sign(T x) {
  return (x > 0) ? 1 : ((x < 0) ? -1 : 0);
}
// [[odin.dust::cpp_std(C++14)]]
// [[odin.dust::linking_to(lostturnip)]]
#include <lostturnip.hpp>
#include <dust/random/math.hpp>
#include <dust/random/density.hpp>
#include <dust/random/random.hpp>

template <typename real_type>
constexpr real_type inf = std::numeric_limits<real_type>::infinity();

template <typename real_type>
constexpr real_type eps = std::numeric_limits<real_type>::epsilon();

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type f(real_type x) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return (2809 + 2000 * x + 95 * x * x) / static_cast<real_type>(4904);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type fp(real_type x) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return (2000 + 2 * 95 * x) / static_cast<real_type>(4904);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type fpp(real_type x) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return (2 * 95) / static_cast<real_type>(4904);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type fppp(real_type x) {
  return 0;
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type g(real_type x) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return (2943 + 1009 * x + 477 * x * x + 475 * x * x * x) / static_cast<real_type>(4904);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type gp(real_type x) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return (1009 + 2 * 477 * x + 3 * 475 * x * x) / static_cast<real_type>(4904);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type gpp(real_type x) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return (2 * 477 + 2 * 3 * 475 * x) / static_cast<real_type>(4904);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type gppp(real_type x) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return (2 * 3 * 475) / static_cast<real_type>(4904);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type h(real_type x, real_type hs, real_type hr) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return dust::math::pow(1 - dust::math::log(x) / hr, -hs);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type hp(real_type x, real_type hs, real_type hr) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return hs * dust::math::pow(1 - dust::math::log(x) / hr, -hs - 1) / (hr * x);
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type hpp(real_type x, real_type hs, real_type hr) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return hs * dust::math::pow((hr - dust::math::log(x)) / hr, -hs) *
    (-hr + hs + dust::math::log(x) + 1) / (x * x * dust::math::pow(hr - dust::math::log(x), 2));
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type hppp(real_type x, real_type hs, real_type hr) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  return hs * dust::math::pow((hr - dust::math::log(x)) / hr, -hs) *
    (hs * hs + 3 * hs + 2 * dust::math::pow(hr - dust::math::log(x), 2) - 3 * (hr - dust::math::log(x)) * (hs + 1) + 2) / (x * x * x * dust::math::pow(hr - dust::math::log(x), 3));
}





// pgfs for unvaccinated H :

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type hu(real_type x, real_type vr, real_type V1, real_type V2, real_type v1eff, real_type v2eff, real_type thetav, real_type hs, real_type hr) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  //~ return ( h(x,hs,hr) - hv( x,vr,V1,V2,v1eff,v2eff,thetav,hs,hr ) )/norm;
  const real_type num = h(thetav*x,hs,hr) - vr*V1*v1eff*h(thetav*x,hs,hr) - vr*V2*v2eff*(1-v1eff)*h(thetav*x,hs,hr) ;
  const real_type den = h(thetav,hs,hr) - vr*V1*v1eff*h(thetav,hs,hr) - vr*V2*v2eff*(1-v1eff)*h(thetav,hs,hr) ;
  //~ const real_type num = (1.0-vr*(v1eff*V1+(1-v1eff)*v2eff*V2))*h(x,hs,hr) + h(thetav*x,hs,hr);
  //~ const real_type den = (1.0-vr*(v1eff*V1+(1-v1eff)*v2eff*V2))*h(1.0,hs,hr) - h(thetav,hs,hr);
  return num / den ;
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type hup(real_type x, real_type vr, real_type V1, real_type V2, real_type v1eff, real_type v2eff, real_type thetav, real_type hs, real_type hr) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  //~ return hp(x,hs,hr) - hvp( x,vr,V1,V2,v1eff,v2eff,thetav,hs,hr );
  const real_type num = thetav*hp(thetav*x,hs,hr) - thetav*vr*V1*v1eff*hp(thetav*x,hs,hr) - thetav*vr*V2*v2eff*(1-v1eff)*hp(thetav*x,hs,hr) ;
  const real_type den = h(thetav,hs,hr) - vr*V1*v1eff*h(thetav,hs,hr) - vr*V2*v2eff*(1-v1eff)*h(thetav,hs,hr) ;
  return num / den ;
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type hupp(real_type x, real_type vr, real_type V1, real_type V2, real_type v1eff, real_type v2eff, real_type thetav, real_type hs, real_type hr) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  //~ return hpp(x,hs,hr) - hvpp( x,vr,V1,V2,v1eff,v2eff,thetav,hs,hr );
  const real_type num = thetav*thetav*hpp(thetav*x,hs,hr) - thetav*thetav*vr*V1*v1eff*hpp(thetav*x,hs,hr) - thetav*thetav*vr*V2*v2eff*(1-v1eff)*hpp(thetav*x,hs,hr) ;
  const real_type den = h(thetav,hs,hr) - vr*V1*v1eff*h(thetav,hs,hr) - vr*V2*v2eff*(1-v1eff)*h(thetav,hs,hr) ;
  return num / den ;
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type huppp(real_type x, real_type vr, real_type V1, real_type V2, real_type v1eff, real_type v2eff, real_type thetav, real_type hs, real_type hr) {
  static_assert(std::is_floating_point<real_type>::value, "use with integral type");
  //~ return hppp(x,hs,hr) - hvppp( x,vr,V1,V2,v1eff,v2eff,thetav,hs,hr );
  const real_type num = thetav*thetav*thetav*hppp(thetav*x,hs,hr) - thetav*thetav*thetav*vr*V1*v1eff*hppp(thetav*x,hs,hr) - thetav*thetav*thetav*vr*V2*v2eff*(1-v1eff)*hppp(thetav*x,hs,hr) ;
  const real_type den = h(thetav,hs,hr) - vr*V1*v1eff*h(thetav,hs,hr) - vr*V2*v2eff*(1-v1eff)*h(thetav,hs,hr) ;
  return num / den ;
}




// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type update_theta_vacc4_2(real_type theta_vacc, real_type amt_targetted,
                               real_type hshape, real_type hrate) {
  // Somewhat annoyingly, we can do this as constexpr in gcc but it's
  // not portable as sqrt() is not constexpr in any version of the
  // standard. It's possible that the compiler will work this out for
  // us?
  const real_type tol = dust::math::sqrt(eps<real_type>);
  const real_type p0 = f(theta_vacc) * g(theta_vacc) * h(theta_vacc, hshape, hrate);
  const real_type p1 = dust::math::max(static_cast<real_type>(0.01), p0 - amt_targetted);
  // There's a small optimisation that can be made here by avoiding
  // doing log(exp(x)) in h
  const auto fn = [&](real_type x) {
                    const auto exp_x = dust::math::exp(x);
                    return f(exp_x) * g(exp_x) * dust::math::pow(1 - x / hrate, -hshape) - p1;
                  };
  return dust::math::exp(lostturnip::find<real_type>(fn, -1e4, 0, tol, 1000));
}

// [[odin.dust::register]]
template <typename real_type>
__host__ __device__
real_type update_theta_vacc4_3( real_type prop_vacc_targetted,
                               real_type hshape, real_type hrate) {
  // Somewhat annoyingly, we can do this as constexpr in gcc but it's
  // not portable as sqrt() is not constexpr in any version of the
  // standard. It's possible that the compiler will work this out for
  // us?
  const real_type tol = dust::math::sqrt(eps<real_type>);
  const real_type p1 = 1.0-dust::math::max(static_cast<real_type>(0.0001), prop_vacc_targetted);
  // There's a small optimisation that can be made here by avoiding
  // doing log(exp(x)) in h
  const auto fn = [&](real_type x) {
                    return  dust::math::pow(1 - x / hrate, -hshape) - p1;
                  };
  return dust::math::exp(lostturnip::find<real_type>(fn, -1e6, 0, tol, 1000));
}



template <typename real_type, typename rng_state_type>
__host__ __device__
real_type ll_nbinom(real_type data, real_type model, real_type kappa,
                    real_type exp_noise, rng_state_type& rng_state) {
  if (std::isnan(data)) {
    return 0;
  }
  real_type mu = model +
    dust::random::exponential<real_type>(rng_state, exp_noise);
  return dust::density::negative_binomial_mu(data, kappa, mu, true);
}

template <typename real_type, typename rng_state_type>
__host__ __device__
real_type ll_betabinom(real_type data_a, real_type data_b,
                       real_type model_a, real_type model_b,
                       real_type rho, real_type exp_noise,
                       rng_state_type& rng_state) {
  if (std::isnan(data_a) || std::isnan(data_b)) {
    return 0;
  }
  const real_type noise_a = dust::random::exponential<real_type>(rng_state, exp_noise);
  const real_type noise_b = dust::random::exponential<real_type>(rng_state, exp_noise);
  real_type prob_a = (model_a + noise_a) /
    (model_a + noise_a + model_b + noise_b);
  return dust::density::beta_binomial(data_a, data_a + data_b, prob_a, rho, true);
}

template <typename real_type>
__host__ __device__
real_type calc_delta(real_type delta0, real_type delta1, real_type delta_slope,
                    real_type time) {
  real_type delta_curr = delta0 + delta_slope * time;
  return dust::math::max(static_cast<real_type>(0.01),
                         dust::math::min(delta1, delta_curr));
}
// [[odin.dust::compare_data(Ytravel = real_type)]]
// [[odin.dust::compare_data(Yendog = real_type)]]
// [[odin.dust::compare_data(Yunk = real_type)]]
// [[odin.dust::compare_function]]
template <typename T>
typename T::real_type
compare(const typename T::real_type * state,
        const typename T::data_type& data,
        const typename T::internal_type internal,
        std::shared_ptr<const typename T::shared_type> shared,
        typename T::rng_state_type& rng_state) {
  typedef typename T::real_type real_type;
  const real_type model_newI = state[19];
  const real_type delta = calc_delta(shared->delta0, shared->delta1,
                                     shared->delta_slope, state[33]);
  const real_type cases = dust::math::ceil(model_newI * delta);
  const real_type Yknown = data.Ytravel + data.Yendog;
  const real_type Y = dust::math::ceil(Yknown + data.Yunk);
  const real_type model_p = state[21] / model_newI;

  real_type ret = 0;
  if (!std::isnan(Y)) {
    real_type ll_cases = ll_nbinom(Y, cases, shared->kappa_cases,
                                   shared->exp_noise, rng_state);

    real_type ll_travel = 0;
    if (Yknown > 0) {
      if (model_newI == 0) {
      ll_travel = -inf<real_type>;
      } else {
        ll_travel = dust::density::binomial(dust::math::ceil(data.Ytravel),
                                            dust::math::ceil(Yknown),
                                            model_p, true);
      }
    }

    ret = ll_cases + ll_travel;
  }

  return ret;
}
// [[dust::class(model)]]
// [[dust::time_type(discrete)]]
// [[dust::param(beta_step, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(dseedrate_step, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(N, has_default = TRUE, default_value = 750000L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta0, has_default = TRUE, default_value = 2.25, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta_freq, has_default = TRUE, default_value = 7L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta_sd, has_default = TRUE, default_value = 0.15, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(cumulative_partners_days, has_default = TRUE, default_value = 90L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta0, has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta1, has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta_slope, has_default = TRUE, default_value = 0L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(dseedrate0, has_default = TRUE, default_value = 0L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(dt, has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(etaf, has_default = TRUE, default_value = 0.005, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(etag, has_default = TRUE, default_value = 0.01, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(exp_noise, has_default = TRUE, default_value = 1000000L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(gamma0, has_default = TRUE, default_value = 0.125, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(gamma1, has_default = TRUE, default_value = 0.25, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(hrate, has_default = TRUE, default_value = 12.95, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(hshape, has_default = TRUE, default_value = 0.26, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(i0, has_default = TRUE, default_value = 0L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(kappa_cases, has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(rho_travel, has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(seedrate0, has_default = TRUE, default_value = 0.75, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(seedrate_sd, has_default = TRUE, default_value = 0.75, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(stochastic_behaviour, has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(use_new_compare, has_default = TRUE, default_value = 0L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_doses, has_default = TRUE, default_value = 50000L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_doses2, has_default = TRUE, default_value = 15000L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_duration, has_default = TRUE, default_value = 55L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_duration2, has_default = TRUE, default_value = 55L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_efficacy, has_default = TRUE, default_value = 0.78, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_efficacy2, has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_freq, has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_start_day, has_default = TRUE, default_value = 91L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_start_day2, has_default = TRUE, default_value = list("+", 91L, 45L), rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(vacc_targetted, has_default = TRUE, default_value = 0.8, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
class model {
public:
  using real_type = double;
  using rng_state_type = dust::random::generator<real_type>;
  struct __align__(16) data_type {
    real_type Ytravel;
    real_type Yendog;
    real_type Yunk;
  };
  struct shared_type {
    real_type N;
    real_type beta0;
    real_type beta_freq;
    real_type beta_sd;
    std::vector<real_type> beta_step;
    real_type cumulative_partners_days;
    real_type delta0;
    real_type delta1;
    real_type delta_slope;
    int dim_beta_step;
    int dim_dseedrate_step;
    real_type dseedrate0;
    std::vector<real_type> dseedrate_step;
    real_type dt;
    real_type etaf;
    real_type etag;
    real_type exp_noise;
    real_type fp1;
    real_type gamma0;
    real_type gamma1;
    real_type gp1;
    real_type hp1;
    real_type hrate;
    real_type hshape;
    real_type i0;
    real_type initial_E;
    real_type initial_Eseed;
    real_type initial_I;
    real_type initial_MEf;
    real_type initial_MEg;
    real_type initial_MEh;
    real_type initial_MIf;
    real_type initial_MIg;
    real_type initial_MIh;
    real_type initial_MSEf;
    real_type initial_MSEg;
    real_type initial_MSIf;
    real_type initial_MSIg;
    real_type initial_MSSf;
    real_type initial_MSSg;
    real_type initial_R;
    real_type initial_S;
    real_type initial_V1;
    real_type initial_V2;
    real_type initial_beta;
    real_type initial_cumulative_partners;
    real_type initial_cutf;
    real_type initial_cutg;
    real_type initial_cuth;
    real_type initial_cuts;
    real_type initial_dseedrate;
    real_type initial_newI;
    real_type initial_newIseed;
    real_type initial_seedrate;
    real_type initial_theta_vacc;
    real_type initial_thetaf;
    real_type initial_thetag;
    real_type initial_thetah;
    real_type kappa_cases;
    real_type rho_travel;
    real_type seedrate0;
    real_type seedrate_sd;
    real_type stochastic_behaviour;
    real_type use_new_compare;
    real_type vacc_amt;
    real_type vacc_amt2;
    real_type vacc_doses;
    real_type vacc_doses2;
    real_type vacc_duration;
    real_type vacc_duration2;
    real_type vacc_efficacy;
    real_type vacc_efficacy2;
    real_type vacc_fin_day;
    real_type vacc_fin_day2;
    real_type vacc_freq;
    real_type vacc_start_day;
    real_type vacc_start_day2;
    real_type vacc_targetted;
    real_type xinit;
  };
  struct internal_type {
    real_type initial_time;
  };
  model(const dust::pars_type<model>& pars) :
    shared(pars.shared), internal(pars.internal) {
  }
  size_t size() const {
    return 34;
  }
  std::vector<real_type> initial(size_t step, rng_state_type& rng_state) {
    std::vector<real_type> state(34);
    internal.initial_time = step;
    state[0] = shared->initial_thetaf;
    state[1] = shared->initial_MSEf;
    state[2] = shared->initial_MEf;
    state[3] = shared->initial_MSSf;
    state[4] = shared->initial_MSIf;
    state[5] = shared->initial_MIf;
    state[6] = shared->initial_thetag;
    state[7] = shared->initial_MSEg;
    state[8] = shared->initial_MEg;
    state[9] = shared->initial_MSSg;
    state[10] = shared->initial_MSIg;
    state[11] = shared->initial_MIg;
    state[12] = shared->initial_thetah;
    state[13] = shared->initial_MEh;
    state[14] = shared->initial_MIh;
    state[15] = shared->initial_S;
    state[16] = shared->initial_E;
    state[17] = shared->initial_I;
    state[18] = shared->initial_R;
    state[19] = shared->initial_newI;
    state[20] = shared->initial_Eseed;
    state[21] = shared->initial_newIseed;
    state[22] = shared->initial_cutf;
    state[23] = shared->initial_cutg;
    state[24] = shared->initial_cuth;
    state[25] = shared->initial_cuts;
    state[26] = shared->initial_seedrate;
    state[27] = shared->initial_dseedrate;
    state[28] = shared->initial_theta_vacc;
    state[29] = shared->initial_beta;
    state[30] = shared->initial_cumulative_partners;
    state[31] = shared->initial_V1;
    state[32] = shared->initial_V2;
    state[33] = internal.initial_time;
    return state;
  }
  void update(size_t step, const real_type * state, rng_state_type& rng_state, real_type * state_next) {
    const real_type time = state[33];
    const real_type thetaf = state[0];
    const real_type MSEf = state[1];
    const real_type MEf = state[2];
    const real_type MSSf = state[3];
    const real_type MSIf = state[4];
    const real_type MIf = state[5];
    const real_type thetag = state[6];
    const real_type MSEg = state[7];
    const real_type MEg = state[8];
    const real_type MSSg = state[9];
    const real_type MSIg = state[10];
    const real_type MIg = state[11];
    const real_type thetah = state[12];
    const real_type MEh = state[13];
    const real_type MIh = state[14];
    const real_type S = state[15];
    const real_type E = state[16];
    const real_type I = state[17];
    const real_type R = state[18];
    const real_type newI = state[19];
    const real_type Eseed = state[20];
    const real_type newIseed = state[21];
    const real_type cutf = state[22];
    const real_type cutg = state[23];
    const real_type cuth = state[24];
    const real_type cuts = state[25];
    const real_type seedrate = state[26];
    const real_type dseedrate = state[27];
    const real_type theta_vacc = state[28];
    const real_type beta = state[29];
    const real_type V1 = state[31];
    const real_type V2 = state[32];
    real_type I_next = dust::math::max(static_cast<real_type>(0), I + shared->gamma0 * E * shared->dt - shared->gamma1 * I * shared->dt);
    real_type R_next = dust::math::max(static_cast<real_type>(0), R + shared->gamma1 * I * shared->dt);
    real_type beta_rw = (fmodr<real_type>(time, shared->beta_freq) == 0 ? dust::math::max(static_cast<real_type>(0), dust::random::normal<real_type>(rng_state, beta, shared->beta_sd)) : beta);
    real_type dMIf = - shared->gamma1 * MIf * shared->dt + shared->gamma0 * MEf * shared->dt;
    real_type dMIg = - shared->gamma1 * MIg * shared->dt + shared->gamma0 * MEg * shared->dt;
    real_type dMIh = - shared->gamma1 * MIh * shared->dt + shared->gamma0 * MEh * shared->dt;
    real_type dseedrate_rw = (fmodr<real_type>(time, shared->beta_freq) == 0 ? dust::random::normal<real_type>(rng_state, dseedrate, shared->seedrate_sd) : dseedrate);
    real_type meanfield_delta_si_f = (thetaf * fpp(thetaf) / (real_type) fp(thetaf));
    real_type meanfield_delta_si_g = (thetag * gpp(thetag) / (real_type) gp(thetag));
    real_type reset_weekly = fmodr<real_type>(step, 7) == 0;
    real_type u2f = (thetaf * fpp(thetaf) + dust::math::pow(thetaf, 2) * fppp(thetaf)) / (real_type) fp(thetaf);
    real_type u2g = (thetag * gpp(thetag) + dust::math::pow(thetag, 2) * gppp(thetag)) / (real_type) gp(thetag);
    state_next[33] = (step + 1) * shared->dt;
    real_type veff = (V1 > 0 ? V1 * ((V2 / (real_type) V1) * (1 - shared->vacc_efficacy) * shared->vacc_efficacy2 + (1 - V2 / (real_type) V1) * shared->vacc_efficacy) : 0);
    real_type MSf = thetaf * (1 - veff) * fp(thetaf) / (real_type) shared->fp1;
    real_type MSg = thetag * (1 - veff) * gp(thetag) / (real_type) shared->gp1;
    real_type add_vaccine = (time >= shared->vacc_start_day) && (time <= shared->vacc_fin_day) && ((fmodr<real_type>((time - shared->vacc_start_day), shared->vacc_freq)) == 0);
    real_type add_vaccine2 = (time >= shared->vacc_start_day2) && (time <= shared->vacc_fin_day2) && ((fmodr<real_type>((time - shared->vacc_start_day2), shared->vacc_freq)) == 0);
    real_type beta_det = (static_cast<int>(step) >= shared->dim_beta_step ? shared->beta_step[shared->dim_beta_step - 1] : shared->beta_step[step + 1 - 1]);
    real_type dseedrate_det = (static_cast<int>(step) >= shared->dim_dseedrate_step ? shared->dseedrate_step[shared->dim_dseedrate_step - 1] : shared->dseedrate_step[step + 1 - 1]);
    real_type newI_next = ((reset_weekly ? 0 : newI)) + shared->gamma0 * E * shared->dt;
    real_type newIseed_next = ((reset_weekly ? 0 : newIseed)) + shared->gamma0 * Eseed * shared->dt;
    real_type u1f = meanfield_delta_si_f;
    real_type u1g = meanfield_delta_si_g;
    state_next[17] = I_next;
    state_next[5] = dust::math::max(static_cast<real_type>(0), MIf + dMIf);
    state_next[11] = dust::math::max(static_cast<real_type>(0), MIg + dMIg);
    state_next[14] = dust::math::max(static_cast<real_type>(0), MIh + dMIh);
    state_next[18] = R_next;
    real_type veff_targetted = veff * shared->vacc_targetted;
    real_type veff_untargetted = veff * (1 - shared->vacc_targetted);
    real_type V1_next = (add_vaccine ? V1 + shared->vacc_amt / (real_type) shared->N : V1);
    real_type V2_next = (add_vaccine2 ? V2 + shared->vacc_amt2 / (real_type) shared->N : V2);
    real_type beta_next = (shared->stochastic_behaviour ? beta_rw : beta_det);
    real_type dseedrate_next = (shared->stochastic_behaviour ? dseedrate_rw : dseedrate_det);
    real_type theta_vacc_use = (add_vaccine ? update_theta_vacc4_3(veff_targetted, shared->hshape, shared->hrate) : theta_vacc);
    state_next[19] = newI_next;
    state_next[21] = newIseed_next;
    real_type vacc_rescale = (add_vaccine ? 1 - (shared->vacc_efficacy * shared->vacc_amt / (real_type) shared->N + (1 - shared->vacc_efficacy) * shared->vacc_efficacy2 * shared->vacc_amt2 / (real_type) shared->N) : 1);
    real_type vf = dust::math::min(u2f - dust::math::pow(u1f, 2), 2 * meanfield_delta_si_f);
    real_type vg = dust::math::min(u2g - dust::math::pow(u1g, 2), 3 * meanfield_delta_si_g);
    real_type MSEf_ = MSEf * vacc_rescale;
    real_type MSEg_ = MSEg * vacc_rescale;
    real_type MSIf_ = MSIf * vacc_rescale;
    real_type MSIg_ = MSIg * vacc_rescale;
    real_type MSSf_ = MSSf * dust::math::pow(vacc_rescale, 2);
    real_type MSSg_ = MSSg * dust::math::pow(vacc_rescale, 2);
    real_type MSh = (1 - veff_untargetted) * thetah * theta_vacc_use * hp(thetah * theta_vacc_use, shared->hshape, shared->hrate) / (real_type) shared->hp1;
    real_type dot_thetah = thetah * theta_vacc_use;
    real_type hu1 = hu(thetah, shared->vacc_targetted, V1, V2, shared->vacc_efficacy, shared->vacc_efficacy2, theta_vacc_use, shared->hshape, shared->hrate);
    real_type hup1 = hup(thetah, shared->vacc_targetted, V1, V2, shared->vacc_efficacy, shared->vacc_efficacy2, theta_vacc_use, shared->hshape, shared->hrate);
    real_type meanfield_delta_si_h = (1 + thetah * hupp(thetah, shared->vacc_targetted, V1, V2, shared->vacc_efficacy, shared->vacc_efficacy2, theta_vacc_use, shared->hshape, shared->hrate) / (real_type) hup(thetah, shared->vacc_targetted, V1, V2, shared->vacc_efficacy, shared->vacc_efficacy2, theta_vacc_use, shared->hshape, shared->hrate));
    real_type rf = beta_next * static_cast<real_type>(1.5) / (real_type) 7;
    real_type rg = beta_next * 1 / (real_type) 7;
    real_type seedrate_next = dust::math::max(static_cast<real_type>(0), seedrate + dseedrate_next * shared->dt);
    state_next[31] = V1_next;
    state_next[32] = V2_next;
    state_next[29] = beta_next;
    state_next[27] = dseedrate_next;
    state_next[28] = theta_vacc_use;
    real_type transmseed = dust::random::poisson<real_type>(rng_state, seedrate_next * shared->dt) * (thetah * hp(thetah, shared->hshape, shared->hrate) / (real_type) shared->hp1);
    real_type tratef = dust::math::max(static_cast<real_type>(0), (MSIf_ * shared->N * shared->fp1 * rf));
    real_type trateg = dust::math::max(static_cast<real_type>(0), MSIg_ * shared->N * shared->gp1 * rg);
    real_type trateh = shared->N * MIh * MSh * shared->hp1;
    real_type u1h = meanfield_delta_si_h;
    state_next[26] = seedrate_next;
    real_type Eseed_next = dust::math::max(static_cast<real_type>(0), Eseed + transmseed - shared->gamma0 * Eseed * shared->dt);
    real_type transmf = dust::random::poisson<real_type>(rng_state, tratef * shared->dt);
    real_type transmg = dust::random::poisson<real_type>(rng_state, trateg * shared->dt);
    real_type transmh = dust::random::poisson<real_type>(rng_state, trateh * shared->dt);
    real_type u2h = huppp(thetah, shared->vacc_targetted, V1, V2, shared->vacc_efficacy, shared->vacc_efficacy2, theta_vacc_use, shared->hshape, shared->hrate) * dust::math::pow(thetah, 2) / (real_type) hup(thetah, shared->vacc_targetted, V1, V2, shared->vacc_efficacy, shared->vacc_efficacy2, theta_vacc_use, shared->hshape, shared->hrate) + 2 * thetah * hupp(thetah, shared->vacc_targetted, V1, V2, shared->vacc_efficacy, shared->vacc_efficacy2, theta_vacc_use, shared->hshape, shared->hrate) / (real_type) hup(thetah, shared->vacc_targetted, V1, V2, shared->vacc_efficacy, shared->vacc_efficacy2, theta_vacc_use, shared->hshape, shared->hrate) + u1h;
    state_next[25] = cuts + transmseed;
    real_type dSf = - transmf / (real_type) shared->N;
    real_type dSg = - transmg / (real_type) shared->N;
    real_type dSh = - (transmh + transmseed) / (real_type) shared->N;
    real_type delta_si_f = ((transmf == 0 ? 0 : dust::math::min(meanfield_delta_si_f * 2, dust::math::max(static_cast<real_type>(0), dust::random::normal<real_type>(rng_state, meanfield_delta_si_f, dust::math::sqrt(vf / (real_type) transmf))))));
    real_type delta_si_g = ((transmg == 0 ? 0 : dust::math::min(meanfield_delta_si_g * 2, dust::math::max(static_cast<real_type>(0), dust::random::normal<real_type>(rng_state, meanfield_delta_si_g, dust::math::sqrt(vg / (real_type) transmg))))));
    real_type dthetaf = - thetaf * transmf / (real_type) (MSf * shared->N * shared->fp1);
    real_type dthetag = - thetag * transmg / (real_type) (MSg * shared->N * shared->gp1);
    real_type dthetah = - thetah * (transmh + transmseed) / (real_type) (shared->N * shared->hp1 * MSh);
    real_type newE = transmf + transmg + transmh + transmseed;
    real_type tauf = (transmf / (real_type) (transmf + transmg + transmh + transmseed));
    real_type taug = (transmg / (real_type) (transmf + transmg + transmh + transmseed));
    real_type tauh = ((transmh + transmseed) / (real_type) (transmf + transmg + transmh + transmseed));
    state_next[20] = Eseed_next;
    state_next[22] = cutf + transmf;
    state_next[23] = cutg + transmg;
    state_next[24] = cuth + transmh;
    real_type vh = dust::math::min(u2h - dust::math::pow(u1h, 2), 2 * meanfield_delta_si_h);
    real_type E_next = dust::math::max(static_cast<real_type>(0), E + newE - shared->gamma0 * E * shared->dt);
    real_type S_next = dust::math::max(static_cast<real_type>(0), S - newE);
    real_type cumulative_partners_next = (1 + shared->etaf * shared->cumulative_partners_days) * (tauf * meanfield_delta_si_f + taug * thetaf * fp(thetaf) / (real_type) f(thetaf) + tauh * thetaf * fp(thetaf) / (real_type) f(thetaf)) + (1 + shared->etag * shared->cumulative_partners_days) * (tauf * thetag * gp(thetag) / (real_type) g(thetag) + taug * meanfield_delta_si_g + tauh * thetag * gp(thetag) / (real_type) g(thetag)) + shared->cumulative_partners_days * (tauf * dot_thetah * hp(dot_thetah, shared->hshape, shared->hrate) / (real_type) h(dot_thetah, shared->hshape, shared->hrate) + taug * dot_thetah * hp(dot_thetah, shared->hshape, shared->hrate) / (real_type) h(dot_thetah, shared->hshape, shared->hrate) + tauh * meanfield_delta_si_h);
    real_type dMEf = - shared->gamma0 * MEf * shared->dt + (- dSf) * ((1 + delta_si_f) / (real_type) shared->fp1) + ((- dSg) + (- dSh)) * (thetaf * fp(thetaf) / (real_type) f(thetaf) / (real_type) shared->fp1);
    real_type dMEg = - shared->gamma0 * MEg * shared->dt + (- dSg) * ((1 + delta_si_g) / (real_type) shared->gp1) + ((- dSf) + (- dSh)) * (thetag * gp(thetag) / (real_type) g(thetag) / (real_type) shared->gp1);
    real_type dMSEf = - shared->gamma1 * MSEf_ * shared->dt + shared->etaf * MSf * MEf * shared->dt - shared->etaf * MSEf_ * shared->dt + (- dSf) * (delta_si_f / (real_type) shared->fp1) * (MSSf_ / (real_type) MSf - MSEf_ / (real_type) MSf) + (- dSg) * (thetaf * fp(thetaf) / (real_type) f(thetaf) / (real_type) shared->fp1) * (MSSf_ / (real_type) MSf - MSEf_ / (real_type) MSf) + (- dSh) * (thetaf * fp(thetaf) / (real_type) f(thetaf) / (real_type) shared->fp1) * (MSSf_ / (real_type) MSf - MSEf_ / (real_type) MSf);
    real_type dMSEg = - shared->gamma0 * MSEg_ * shared->dt + shared->etag * MSg * MEg * shared->dt - shared->etag * MSEg_ * shared->dt + (- dSg) * (delta_si_g / (real_type) shared->gp1) * (MSSg_ / (real_type) MSg) + (- dSf) * (thetag * gp(thetag) / (real_type) g(thetag) / (real_type) shared->gp1) * (MSSg_ / (real_type) MSg - MSEg_ / (real_type) MSg) + (- dSh) * (thetag * gp(thetag) / (real_type) g(thetag) / (real_type) shared->gp1) * (MSSg_ / (real_type) MSg - MSEg_ / (real_type) MSg);
    real_type dMSIf = - rf * MSIf_ * shared->dt - shared->gamma1 * MSIf_ * shared->dt + shared->gamma0 * MSEf_ * shared->dt + shared->etaf * MSf * MIf * shared->dt - shared->etaf * MSIf_ * shared->dt + (- dSf) * (delta_si_f / (real_type) shared->fp1) * (- MSIf_ / (real_type) MSf) + (- dSg) * (thetaf * fp(thetaf) / (real_type) f(thetaf) / (real_type) shared->fp1) * (- MSIf_ / (real_type) MSf) + (- dSh) * (thetaf * fp(thetaf) / (real_type) f(thetaf) / (real_type) shared->fp1) * (- MSIf_ / (real_type) MSf);
    real_type dMSIg = - rg * MSIg_ * shared->dt - shared->gamma1 * MSIg_ * shared->dt + shared->gamma0 * MSEg_ * shared->dt + shared->etag * MSg * MIg * shared->dt - shared->etag * MSIg_ * shared->dt + (- dSg) * (delta_si_g / (real_type) shared->gp1) * (- MSIg_ / (real_type) MSg) + (- dSf) * (thetag * gp(thetag) / (real_type) g(thetag) / (real_type) shared->gp1) * (- MSIg_ / (real_type) MSg) + (- dSh) * (thetag * gp(thetag) / (real_type) g(thetag) / (real_type) shared->gp1) * (- MSIg_ / (real_type) MSg);
    real_type dMSSf = 1 * shared->etaf * dust::math::pow(MSf, 2) * shared->dt - shared->etaf * MSSf_ * shared->dt - 2 * (- dSf) * (delta_si_f / (real_type) shared->fp1) * MSSf_ / (real_type) MSf - 2 * ((- dSg) + (- dSh)) * (thetaf * fp(thetaf) / (real_type) f(thetaf) / (real_type) shared->fp1) * MSSf_ / (real_type) MSf;
    real_type dMSSg = 1 * shared->etag * dust::math::pow(MSg, 2) * shared->dt - shared->etag * MSSg_ * shared->dt - 2 * (- dSg) * (delta_si_g / (real_type) shared->gp1) * MSSg_ / (real_type) MSg - 2 * ((- dSf) + (- dSh)) * (thetag * gp(thetag) / (real_type) g(thetag) / (real_type) shared->gp1) * MSSg_ / (real_type) MSg;
    real_type delta_si_h = ((transmh == 0 ? 0 : dust::math::min(meanfield_delta_si_h * 2, dust::math::max(static_cast<real_type>(0), dust::random::normal<real_type>(rng_state, meanfield_delta_si_h, dust::math::sqrt(vh / (real_type) transmh))))));
    state_next[0] = dust::math::max(static_cast<real_type>(static_cast<real_type>(1.0000000000000001e-09)), dust::math::min(static_cast<real_type>(1), thetaf + dthetaf));
    state_next[6] = dust::math::max(static_cast<real_type>(static_cast<real_type>(1.0000000000000001e-09)), dust::math::min(static_cast<real_type>(1), thetag + dthetag));
    state_next[12] = dust::math::max(static_cast<real_type>(static_cast<real_type>(1.0000000000000001e-09)), dust::math::min(static_cast<real_type>(1), thetah + dthetah));
    real_type dMEh = - shared->gamma0 * MEh * shared->dt + (- dSh) * (delta_si_h / (real_type) shared->hp1) + ((- dSf) + (- dSg)) * (thetah * hup1 / (real_type) hu1 / (real_type) shared->hp1);
    state_next[16] = E_next;
    state_next[2] = dust::math::max(static_cast<real_type>(0), MEf + dMEf);
    state_next[8] = dust::math::max(static_cast<real_type>(0), MEg + dMEg);
    state_next[1] = dust::math::max(static_cast<real_type>(0), dust::math::min(static_cast<real_type>(1), MSEf_ + dMSEf));
    state_next[7] = dust::math::max(static_cast<real_type>(0), dust::math::min(static_cast<real_type>(1), MSEg_ + dMSEg));
    state_next[4] = dust::math::max(static_cast<real_type>(0), dust::math::min(static_cast<real_type>(1), MSIf_ + dMSIf));
    state_next[10] = dust::math::max(static_cast<real_type>(0), dust::math::min(static_cast<real_type>(1), MSIg_ + dMSIg));
    state_next[3] = dust::math::max(static_cast<real_type>(0), dust::math::min(static_cast<real_type>(1), MSSf_ + dMSSf));
    state_next[9] = dust::math::max(static_cast<real_type>(0), dust::math::min(static_cast<real_type>(1), MSSg_ + dMSSg));
    state_next[15] = S_next;
    state_next[30] = cumulative_partners_next;
    state_next[13] = dust::math::max(static_cast<real_type>(0), MEh + dMEh);
  }
  real_type compare_data(const real_type * state, const data_type& data, rng_state_type& rng_state) {
    return compare<model>(state, data, internal, shared, rng_state);
  }
private:
  std::shared_ptr<const shared_type> shared;
  internal_type internal;
};
#include <array>
#include <cpp11/R.hpp>
#include <cpp11/sexp.hpp>
#include <cpp11/doubles.hpp>
#include <cpp11/integers.hpp>
#include <cpp11/list.hpp>
#include <cpp11/strings.hpp>
#include <memory>
#include <vector>

template <typename T>
inline bool is_na(T x);

template <>
inline bool is_na(int x) {
  return x == NA_INTEGER;
}

template <>
inline bool is_na(double x) {
  return ISNA(x);
}

inline size_t object_length(cpp11::sexp x) {
  return ::Rf_xlength(x);
}

template <typename T>
void user_check_value(T value, const char *name, T min, T max) {
  if (is_na(value)) {
    cpp11::stop("'%s' must not be NA", name);
  }
  if (!is_na(min) && value < min) {
    cpp11::stop("Expected '%s' to be at least %g", name, (double) min);
  }
  if (!is_na(max) && value > max) {
    cpp11::stop("Expected '%s' to be at most %g", name, (double) max);
  }
}

template <typename T>
void user_check_array_value(const std::vector<T>& value, const char *name,
                            T min, T max) {
  for (auto& x : value) {
    user_check_value(x, name, min, max);
  }
}

inline size_t user_get_array_rank(cpp11::sexp x) {
  if (!::Rf_isArray(x)) {
    return 1;
  } else {
    cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
    return dim.size();
  }
}

template <size_t N>
void user_check_array_rank(cpp11::sexp x, const char *name) {
  size_t rank = user_get_array_rank(x);
  if (rank != N) {
    if (N == 1) {
      cpp11::stop("Expected a vector for '%s'", name);
    } else if (N == 2) {
      cpp11::stop("Expected a matrix for '%s'", name);
    } else {
      cpp11::stop("Expected an array of rank %d for '%s'", N, name);
    }
  }
}

template <size_t N>
void user_check_array_dim(cpp11::sexp x, const char *name,
                          const std::array<int, N>& dim_expected) {
  cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  for (size_t i = 0; i < N; ++i) {
    if (dim[(int)i] != dim_expected[i]) {
      Rf_error("Incorrect size of dimension %d of '%s' (expected %d)",
               i + 1, name, dim_expected[i]);
    }
  }
}

template <>
inline void user_check_array_dim<1>(cpp11::sexp x, const char *name,
                                    const std::array<int, 1>& dim_expected) {
  if ((int)object_length(x) != dim_expected[0]) {
    cpp11::stop("Expected length %d value for '%s'", dim_expected[0], name);
  }
}

template <size_t N>
void user_set_array_dim(cpp11::sexp x, const char *name,
                        std::array<int, N>& dim) {
  cpp11::integers dim_given = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  std::copy(dim_given.begin(), dim_given.end(), dim.begin());
}

template <>
inline void user_set_array_dim<1>(cpp11::sexp x, const char *name,
                                  std::array<int, 1>& dim) {
  dim[0] = object_length(x);
}

template <typename T>
T user_get_scalar(cpp11::list user, const char *name,
                  const T previous, T min, T max) {
  T ret = previous;
  cpp11::sexp x = user[name];
  if (x != R_NilValue) {
    if (object_length(x) != 1) {
      cpp11::stop("Expected a scalar numeric for '%s'", name);
    }
    // TODO: when we're getting out an integer this is a bit too relaxed
    if (TYPEOF(x) == REALSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else if (TYPEOF(x) == INTSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else {
      cpp11::stop("Expected a numeric value for %s", name);
    }
  }

  if (is_na(ret)) {
    cpp11::stop("Expected a value for '%s'", name);
  }
  user_check_value<T>(ret, name, min, max);
  return ret;
}

template <>
inline float user_get_scalar<float>(cpp11::list user, const char *name,
                                    const float previous, float min, float max) {
  double value = user_get_scalar<double>(user, name, previous, min, max);
  return static_cast<float>(value);
}

template <typename T>
std::vector<T> user_get_array_value(cpp11::sexp x, const char * name,
                                    T min, T max) {
  std::vector<T> ret = cpp11::as_cpp<std::vector<T>>(x);
  user_check_array_value<T>(ret, name, min, max);
  return ret;
}

template <typename T, size_t N>
std::vector<T> user_get_array_fixed(cpp11::list user, const char *name,
                                    const std::vector<T> previous,
                                    const std::array<int, N>& dim,
                                    T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_check_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <typename T, size_t N>
std::vector<T> user_get_array_variable(cpp11::list user, const char *name,
                                       std::vector<T> previous,
                                       std::array<int, N>& dim,
                                       T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_set_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <>
inline std::vector<float> user_get_array_value(cpp11::sexp x, const char * name,
                                               float min, float max) {
  // NOTE: possible under/overflow here for min/max because we've
  // downcast this.
  std::vector<double> value = user_get_array_value<double>(x, name, min, max);
  std::vector<float> ret(value.size());
  std::copy(value.begin(), value.end(), ret.begin());
  return ret;
}

// This is sum with inclusive "from", exclusive "to", following the
// same function in odin
template <typename real_type, typename container>
__host__ __device__
real_type odin_sum1(const container x, size_t from, size_t to) {
  real_type tot = 0.0;
  for (size_t i = from; i < to; ++i) {
    tot += x[i];
  }
  return tot;
}

inline cpp11::writable::integers integer_sequence(size_t from, size_t len) {
  cpp11::writable::integers ret(len);
  int* data = INTEGER(ret);
  for (size_t i = 0, j = from; i < len; ++i, ++j) {
    data[i] = j;
  }
  return ret;
}
namespace dust {
template<>
dust::pars_type<model> dust_pars<model>(cpp11::list user) {
  using real_type = typename model::real_type;
  auto shared = std::make_shared<model::shared_type>();
  model::internal_type internal;
  shared->fp1 = fp(static_cast<real_type>(1));
  shared->gp1 = gp(static_cast<real_type>(1));
  shared->initial_Eseed = 0;
  shared->initial_MEf = 0;
  shared->initial_MEg = 0;
  shared->initial_MIf = 0;
  shared->initial_MIg = 0;
  shared->initial_MSEf = 0;
  shared->initial_MSEg = 0;
  shared->initial_MSIf = 0;
  shared->initial_MSIg = 0;
  shared->initial_MSSf = 1;
  shared->initial_MSSg = 1;
  shared->initial_R = 0;
  shared->initial_V1 = 0;
  shared->initial_V2 = 0;
  shared->initial_cumulative_partners = 0;
  shared->initial_cutf = 0;
  shared->initial_cutg = 0;
  shared->initial_cuth = 0;
  shared->initial_cuts = 0;
  shared->initial_newI = 0;
  shared->initial_newIseed = 0;
  shared->initial_theta_vacc = 1;
  shared->initial_thetaf = 1;
  shared->initial_thetag = 1;
  shared->N = 750000;
  shared->beta0 = static_cast<real_type>(2.25);
  shared->beta_freq = 7;
  shared->beta_sd = static_cast<real_type>(0.14999999999999999);
  shared->cumulative_partners_days = 90;
  shared->delta0 = static_cast<real_type>(0.5);
  shared->delta1 = static_cast<real_type>(0.5);
  shared->delta_slope = 0;
  shared->dseedrate0 = 0;
  shared->dt = static_cast<real_type>(0.10000000000000001);
  shared->etaf = static_cast<real_type>(0.0050000000000000001);
  shared->etag = static_cast<real_type>(0.01);
  shared->exp_noise = 1000000;
  shared->gamma0 = static_cast<real_type>(0.125);
  shared->gamma1 = static_cast<real_type>(0.25);
  shared->hrate = static_cast<real_type>(12.949999999999999);
  shared->hshape = static_cast<real_type>(0.26000000000000001);
  shared->i0 = 0;
  shared->kappa_cases = 1;
  shared->rho_travel = static_cast<real_type>(0.5);
  shared->seedrate0 = static_cast<real_type>(0.75);
  shared->seedrate_sd = static_cast<real_type>(0.75);
  shared->stochastic_behaviour = 1;
  shared->use_new_compare = 0;
  shared->vacc_doses = 50000;
  shared->vacc_doses2 = 15000;
  shared->vacc_duration = 55;
  shared->vacc_duration2 = 55;
  shared->vacc_efficacy = static_cast<real_type>(0.78000000000000003);
  shared->vacc_efficacy2 = 1;
  shared->vacc_freq = 1;
  shared->vacc_start_day = 91;
  shared->vacc_start_day2 = 91 + 45;
  shared->vacc_targetted = static_cast<real_type>(0.80000000000000004);
  internal.initial_time = 0;
  shared->N = user_get_scalar<real_type>(user, "N", shared->N, NA_REAL, NA_REAL);
  shared->beta0 = user_get_scalar<real_type>(user, "beta0", shared->beta0, NA_REAL, NA_REAL);
  shared->beta_freq = user_get_scalar<real_type>(user, "beta_freq", shared->beta_freq, NA_REAL, NA_REAL);
  shared->beta_sd = user_get_scalar<real_type>(user, "beta_sd", shared->beta_sd, NA_REAL, NA_REAL);
  std::array <int, 1> dim_beta_step;
  shared->beta_step = user_get_array_variable<real_type, 1>(user, "beta_step", shared->beta_step, dim_beta_step, NA_REAL, NA_REAL);
  shared->dim_beta_step = shared->beta_step.size();
  shared->cumulative_partners_days = user_get_scalar<real_type>(user, "cumulative_partners_days", shared->cumulative_partners_days, NA_REAL, NA_REAL);
  shared->delta0 = user_get_scalar<real_type>(user, "delta0", shared->delta0, NA_REAL, NA_REAL);
  shared->delta1 = user_get_scalar<real_type>(user, "delta1", shared->delta1, NA_REAL, NA_REAL);
  shared->delta_slope = user_get_scalar<real_type>(user, "delta_slope", shared->delta_slope, NA_REAL, NA_REAL);
  shared->dseedrate0 = user_get_scalar<real_type>(user, "dseedrate0", shared->dseedrate0, NA_REAL, NA_REAL);
  std::array <int, 1> dim_dseedrate_step;
  shared->dseedrate_step = user_get_array_variable<real_type, 1>(user, "dseedrate_step", shared->dseedrate_step, dim_dseedrate_step, NA_REAL, NA_REAL);
  shared->dim_dseedrate_step = shared->dseedrate_step.size();
  shared->dt = user_get_scalar<real_type>(user, "dt", shared->dt, NA_REAL, NA_REAL);
  shared->etaf = user_get_scalar<real_type>(user, "etaf", shared->etaf, NA_REAL, NA_REAL);
  shared->etag = user_get_scalar<real_type>(user, "etag", shared->etag, NA_REAL, NA_REAL);
  shared->exp_noise = user_get_scalar<real_type>(user, "exp_noise", shared->exp_noise, NA_REAL, NA_REAL);
  shared->gamma0 = user_get_scalar<real_type>(user, "gamma0", shared->gamma0, NA_REAL, NA_REAL);
  shared->gamma1 = user_get_scalar<real_type>(user, "gamma1", shared->gamma1, NA_REAL, NA_REAL);
  shared->hrate = user_get_scalar<real_type>(user, "hrate", shared->hrate, NA_REAL, NA_REAL);
  shared->hshape = user_get_scalar<real_type>(user, "hshape", shared->hshape, NA_REAL, NA_REAL);
  shared->i0 = user_get_scalar<real_type>(user, "i0", shared->i0, NA_REAL, NA_REAL);
  shared->kappa_cases = user_get_scalar<real_type>(user, "kappa_cases", shared->kappa_cases, NA_REAL, NA_REAL);
  shared->rho_travel = user_get_scalar<real_type>(user, "rho_travel", shared->rho_travel, NA_REAL, NA_REAL);
  shared->seedrate0 = user_get_scalar<real_type>(user, "seedrate0", shared->seedrate0, NA_REAL, NA_REAL);
  shared->seedrate_sd = user_get_scalar<real_type>(user, "seedrate_sd", shared->seedrate_sd, NA_REAL, NA_REAL);
  shared->stochastic_behaviour = user_get_scalar<real_type>(user, "stochastic_behaviour", shared->stochastic_behaviour, NA_REAL, NA_REAL);
  shared->use_new_compare = user_get_scalar<real_type>(user, "use_new_compare", shared->use_new_compare, NA_REAL, NA_REAL);
  shared->vacc_doses = user_get_scalar<real_type>(user, "vacc_doses", shared->vacc_doses, NA_REAL, NA_REAL);
  shared->vacc_doses2 = user_get_scalar<real_type>(user, "vacc_doses2", shared->vacc_doses2, NA_REAL, NA_REAL);
  shared->vacc_duration = user_get_scalar<real_type>(user, "vacc_duration", shared->vacc_duration, NA_REAL, NA_REAL);
  shared->vacc_duration2 = user_get_scalar<real_type>(user, "vacc_duration2", shared->vacc_duration2, NA_REAL, NA_REAL);
  shared->vacc_efficacy = user_get_scalar<real_type>(user, "vacc_efficacy", shared->vacc_efficacy, NA_REAL, NA_REAL);
  shared->vacc_efficacy2 = user_get_scalar<real_type>(user, "vacc_efficacy2", shared->vacc_efficacy2, NA_REAL, NA_REAL);
  shared->vacc_freq = user_get_scalar<real_type>(user, "vacc_freq", shared->vacc_freq, NA_REAL, NA_REAL);
  shared->vacc_start_day = user_get_scalar<real_type>(user, "vacc_start_day", shared->vacc_start_day, NA_REAL, NA_REAL);
  shared->vacc_start_day2 = user_get_scalar<real_type>(user, "vacc_start_day2", shared->vacc_start_day2, NA_REAL, NA_REAL);
  shared->vacc_targetted = user_get_scalar<real_type>(user, "vacc_targetted", shared->vacc_targetted, NA_REAL, NA_REAL);
  shared->hp1 = hp(static_cast<real_type>(1), shared->hshape, shared->hrate);
  shared->initial_E = shared->i0 / (real_type) 2;
  shared->initial_I = shared->i0 / (real_type) 2;
  shared->initial_S = shared->N - shared->i0;
  shared->initial_beta = shared->beta0;
  shared->initial_dseedrate = shared->dseedrate0;
  shared->initial_seedrate = shared->seedrate0;
  shared->vacc_amt = shared->dt * dust::math::min(shared->vacc_doses, shared->N) / (real_type) shared->vacc_duration / (real_type) shared->vacc_freq;
  shared->vacc_amt2 = shared->dt * dust::math::min(shared->vacc_doses2, shared->N) / (real_type) shared->vacc_duration2 / (real_type) shared->vacc_freq;
  shared->vacc_fin_day = shared->vacc_start_day + shared->vacc_duration - 1;
  shared->vacc_fin_day2 = shared->vacc_start_day2 + shared->vacc_duration2 - 1;
  shared->xinit = shared->i0 / (real_type) shared->N;
  shared->initial_MEh = shared->xinit / (real_type) 2;
  shared->initial_MIh = shared->xinit / (real_type) 2;
  shared->initial_thetah = 1 - shared->xinit;
  return dust::pars_type<model>(shared, internal);
}
template <>
cpp11::sexp dust_info<model>(const dust::pars_type<model>& pars) {
  const std::shared_ptr<const model::shared_type> shared = pars.shared;
  cpp11::writable::strings nms({"thetaf", "MSEf", "MEf", "MSSf", "MSIf", "MIf", "thetag", "MSEg", "MEg", "MSSg", "MSIg", "MIg", "thetah", "MEh", "MIh", "S", "E", "I", "R", "newI", "Eseed", "newIseed", "cutf", "cutg", "cuth", "cuts", "seedrate", "dseedrate", "theta_vacc", "beta", "cumulative_partners", "V1", "V2", "time"});
  cpp11::writable::list dim(34);
  dim[0] = cpp11::writable::integers({1});
  dim[1] = cpp11::writable::integers({1});
  dim[2] = cpp11::writable::integers({1});
  dim[3] = cpp11::writable::integers({1});
  dim[4] = cpp11::writable::integers({1});
  dim[5] = cpp11::writable::integers({1});
  dim[6] = cpp11::writable::integers({1});
  dim[7] = cpp11::writable::integers({1});
  dim[8] = cpp11::writable::integers({1});
  dim[9] = cpp11::writable::integers({1});
  dim[10] = cpp11::writable::integers({1});
  dim[11] = cpp11::writable::integers({1});
  dim[12] = cpp11::writable::integers({1});
  dim[13] = cpp11::writable::integers({1});
  dim[14] = cpp11::writable::integers({1});
  dim[15] = cpp11::writable::integers({1});
  dim[16] = cpp11::writable::integers({1});
  dim[17] = cpp11::writable::integers({1});
  dim[18] = cpp11::writable::integers({1});
  dim[19] = cpp11::writable::integers({1});
  dim[20] = cpp11::writable::integers({1});
  dim[21] = cpp11::writable::integers({1});
  dim[22] = cpp11::writable::integers({1});
  dim[23] = cpp11::writable::integers({1});
  dim[24] = cpp11::writable::integers({1});
  dim[25] = cpp11::writable::integers({1});
  dim[26] = cpp11::writable::integers({1});
  dim[27] = cpp11::writable::integers({1});
  dim[28] = cpp11::writable::integers({1});
  dim[29] = cpp11::writable::integers({1});
  dim[30] = cpp11::writable::integers({1});
  dim[31] = cpp11::writable::integers({1});
  dim[32] = cpp11::writable::integers({1});
  dim[33] = cpp11::writable::integers({1});
  dim.names() = nms;
  cpp11::writable::list index(34);
  index[0] = cpp11::writable::integers({1});
  index[1] = cpp11::writable::integers({2});
  index[2] = cpp11::writable::integers({3});
  index[3] = cpp11::writable::integers({4});
  index[4] = cpp11::writable::integers({5});
  index[5] = cpp11::writable::integers({6});
  index[6] = cpp11::writable::integers({7});
  index[7] = cpp11::writable::integers({8});
  index[8] = cpp11::writable::integers({9});
  index[9] = cpp11::writable::integers({10});
  index[10] = cpp11::writable::integers({11});
  index[11] = cpp11::writable::integers({12});
  index[12] = cpp11::writable::integers({13});
  index[13] = cpp11::writable::integers({14});
  index[14] = cpp11::writable::integers({15});
  index[15] = cpp11::writable::integers({16});
  index[16] = cpp11::writable::integers({17});
  index[17] = cpp11::writable::integers({18});
  index[18] = cpp11::writable::integers({19});
  index[19] = cpp11::writable::integers({20});
  index[20] = cpp11::writable::integers({21});
  index[21] = cpp11::writable::integers({22});
  index[22] = cpp11::writable::integers({23});
  index[23] = cpp11::writable::integers({24});
  index[24] = cpp11::writable::integers({25});
  index[25] = cpp11::writable::integers({26});
  index[26] = cpp11::writable::integers({27});
  index[27] = cpp11::writable::integers({28});
  index[28] = cpp11::writable::integers({29});
  index[29] = cpp11::writable::integers({30});
  index[30] = cpp11::writable::integers({31});
  index[31] = cpp11::writable::integers({32});
  index[32] = cpp11::writable::integers({33});
  index[33] = cpp11::writable::integers({34});
  index.names() = nms;
  size_t len = 34;
  using namespace cpp11::literals;
  return cpp11::writable::list({
           "dim"_nm = dim,
           "len"_nm = len,
           "index"_nm = index});
}
template <>
model::data_type dust_data<model>(cpp11::list data) {
  using real_type = model::real_type;
  return model::data_type{
      cpp11::as_cpp<real_type>(data["Ytravel"]),
      cpp11::as_cpp<real_type>(data["Yendog"]),
      cpp11::as_cpp<real_type>(data["Yunk"])
    };
}
}
